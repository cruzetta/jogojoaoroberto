<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout Deluxe 3.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --primary-color: #e94560;
            --secondary-color: #16213e;
            --accent-color: #0f3460;
            --font-color: #f0f0f0;
            --font-pixel: 'Press Start 2P', cursive;
            --font-ui: 'Roboto Condensed', sans-serif;
        }

        /* ** RESPONSIVIDADE ** */
        html, body {
            background-color: var(--bg-color);
            color: var(--font-color);
            font-family: var(--font-ui);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            margin: 0;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 650px;
            aspect-ratio: 800 / 650;
            background-color: var(--secondary-color);
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.5);
            border: 3px solid var(--accent-color);
            display: flex;
            flex-direction: column;
        }

        #ui-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5vmin 3vmin;
            background-color: var(--accent-color);
            font-family: var(--font-pixel);
            font-size: 1.8vmin;
            flex-shrink: 0;
            border-bottom: 3px solid var(--secondary-color);
        }

        .ui-element span {
            margin-left: 1.5vmin;
        }

        #powerup-indicators {
            position: absolute;
            bottom: 1vmin;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1.5vmin;
            z-index: 10;
        }
        
        .powerup-icon {
            background: rgba(0,0,0,0.5);
            padding: 0.8vmin;
            border-radius: 5px;
            font-family: var(--font-pixel);
            font-size: 1.5vmin;
            border: 1px solid var(--primary-color);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #000;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            padding: 3vmin;
            box-sizing: border-box;
            font-family: var(--font-pixel);
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.5s, visibility 0s 0.5s;
        }

        .overlay.visible {
            visibility: visible;
            opacity: 1;
            transition: opacity 0.5s;
        }
        
        .overlay h1 {
            color: var(--primary-color);
            font-size: 5vmin;
            margin-bottom: 3vmin;
            text-shadow: 0 0 10px var(--primary-color);
        }

        .overlay p {
            font-size: 2vmin;
            line-height: 1.6;
            max-width: 90%;
            margin-bottom: 4vmin;
        }

        .btn {
            font-family: var(--font-pixel);
            font-size: 2.2vmin;
            padding: 2vmin 4vmin;
            background-color: var(--primary-color);
            color: var(--font-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s ease;
            margin: 1.5vmin;
            box-shadow: 0 4px 0 darken(var(--primary-color), 10%);
        }

        #level-select-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
            gap: 1.5vmin;
            width: 90%;
            margin-top: 20px;
        }

        .level-box {
            min-width: 40px;
            aspect-ratio: 1 / 1;
            background: var(--secondary-color);
            border: 2px solid var(--accent-color);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5vmin;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .level-box.unlocked:hover {
            background: var(--accent-color);
            transform: scale(1.1);
        }

        .level-box.locked {
            background: #333;
            color: #666;
            cursor: not-allowed;
            font-size: 0;
        }
        
        .level-box.locked::after {
            content: 'üîí';
            font-size: 4vmin;
        }

        #highscore-table {
            width: 80%;
            margin-top: 20px;
            border-collapse: collapse;
            font-size: 2vmin;
        }
        
        #nickname-input {
            padding: 1.5vmin;
            font-family: var(--font-pixel);
            font-size: 2vmin;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="ui-bar">
            <div id="score" class="ui-element">SCORE: <span>0</span></div>
            <div id="level" class="ui-element">LEVEL: <span>1</span></div>
            <div id="lives" class="ui-element">LIVES: <span>‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
        </div>
        <canvas id="gameCanvas"></canvas> <!-- Tamanho removido -->
        <div id="powerup-indicators"></div>

        <!-- Telas de Overlay -->
        <div id="start-screen" class="overlay visible">
            <h1>Breakout Deluxe 3.0</h1>
            <p>Destrua todos os tijolos para avan√ßar. Use o mouse/toque para mover a raquete. Colete itens para b√¥nus... ou malus!</p>
            <button id="start-game-btn" class="btn">Iniciar Jogo</button>
            <button id="level-select-btn" class="btn">Selecionar N√≠vel</button>
            <button id="highscore-btn" class="btn">Recordes</button>
        </div>
        
        <div id="level-select-screen" class="overlay">
            <h1>Selecionar N√≠vel</h1>
            <div id="level-select-grid"></div>
            <button class="btn back-to-menu-btn">Voltar ao Menu</button>
        </div>

        <div id="highscore-screen" class="overlay">
            <h1>Recordes</h1>
            <table id="highscore-table">
                <thead>
                    <tr><th>#</th><th>Nome</th><th>Pontua√ß√£o</th></tr>
                </thead>
                <tbody></tbody>
            </table>
            <button class="btn back-to-menu-btn">Voltar ao Menu</button>
        </div>

        <div id="game-over-screen" class="overlay">
            <h1>Fim de Jogo</h1>
            <p id="final-score"></p>
            <div id="new-highscore-entry" style="display:none;">
                <p>Novo Recorde! Digite seu nome:</p>
                <input type="text" id="nickname-input" maxlength="10" placeholder="AAA">
                <button id="submit-score-btn" class="btn">Salvar</button>
            </div>
            <button id="play-again-btn" class="btn">Jogar Novamente</button>
            <button class="btn back-to-menu-btn">Voltar ao Menu</button>
        </div>

        <div id="level-complete-screen" class="overlay">
            <h1>N√≠vel Conclu√≠do!</h1>
            <p id="level-complete-score"></p>
            <button id="next-level-btn" class="btn">Pr√≥ximo N√≠vel</button>
        </div>

        <div id="game-complete-screen" class="overlay">
            <h1>Parab√©ns!</h1>
            <p>Voc√™ completou todos os n√≠veis!</p>
             <p id="final-score-win"></p>
            <div id="new-highscore-entry-win" style="display:none;">
                <p>Novo Recorde! Digite seu nome:</p>
                <input type="text" id="nickname-input-win" maxlength="10" placeholder="AAA">
                <button id="submit-score-btn-win" class="btn">Salvar</button>
            </div>
            <button class="btn back-to-menu-btn">Voltar ao Menu</button>
        </div>

    </div>

    <script type="module">
        // ==================================================================
        // SIMULANDO levels.json - Dados e Configura√ß√£o dos N√≠veis
        // ==================================================================
        const LEVELS_DATA = {
            "levels": [
                 // ** VELOCIDADE DA BOLA AUMENTADA **
                {
                    "level": 1, "config": { "ballSpeed": 4.5, "paddleWidth": 120, "timer": null },
                    "layout": ["1111111111", "1111111111", "0011111100"]
                },
                {
                    "level": 2, "config": { "ballSpeed": 4.7, "paddleWidth": 120, "timer": null },
                    "layout": ["2222222222", "1111111111", "0211111120"]
                },
                {
                    "level": 3, "config": { "ballSpeed": 4.8, "paddleWidth": 120, "timer": null },
                    "layout": ["E0E0E0E0E0", "1111111111", "2020202020", "0101010101"]
                },
                {
                    "level": 4, "config": { "ballSpeed": 5.0, "paddleWidth": 120, "timer": null },
                    "layout": ["I01111110I", "0122222210", "12S0000S21", "001EWW E100"]
                },
                {
                    "level": 5, "config": { "ballSpeed": 5.1, "paddleWidth": 120, "timer": 90 },
                    "layout": ["M11111111M", "1222I22221", "12E1111E21", "001S+S100"]
                },
                {
                    "level": 6, "config": { "ballSpeed": 5.3, "paddleWidth": 110, "timer": null },
                    "layout": ["A0A0A0A0A0", "0202020202", "1111111111"]
                },
                {
                    "level": 7, "config": { "ballSpeed": 5.5, "paddleWidth": 110, "timer": null },
                    "layout": ["IIIIIIIIII", "A1A1A1A1A1", "1A1A1A1A1A", "00E0000E00"]
                },
                {
                    "level": 8, "config": { "ballSpeed": 5.6, "paddleWidth": 110, "timer": 75 },
                    "layout": ["A2A2A2A2A2", "2f2f2f2f2f", "1w1w1w1w1w", "00L0000S00"]
                },
                 {
                    "level": 9, "config": { "ballSpeed": 5.8, "paddleWidth": 100, "timer": null },
                    "layout": ["I0A2222A0I", "0A211112A0", "A21E+E12A", "011 w f 110", "001S00S100"]
                },
                {
                    "level": 10, "config": { "ballSpeed": 6.0, "paddleWidth": 100, "timer": 60 },
                    "layout": ["AAAAAAAAAA", "I22222222I", "0E11II11E0", "001MwwM100", "000SLL S000"]
                }
            ]
        };
        const TOTAL_LEVELS = LEVELS_DATA.levels.length;

        // ==================================================================
        // CANVAS & JOGO - L√≥gica Principal (main.js)
        // ==================================================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameWidth = 800; // Largura base para c√°lculos
        const gameHeight = 600; // Altura base para c√°lculos
        
        let gameState = {};
        
        function resetGameState() {
            gameState = {
                status: 'menu',
                score: 0,
                lives: 3,
                currentLevel: 1,
                paddle: null,
                balls: [],
                bricks: [],
                powerUps: [],
                particles: [],
                screenShake: 0,
                timer: null,
                timerId: null,
                activeEffects: {},
                playerProgress: {
                    unlockedLevel: parseInt(localStorage.getItem('unlockedLevel') || '1')
                }
            };
        }

        // ** RESPONSIVIDADE **
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const aspectRatio = gameWidth / gameHeight;
            let newWidth = container.clientWidth;
            let newHeight = container.clientHeight - document.getElementById('ui-bar').offsetHeight;

            if (newWidth / newHeight > aspectRatio) {
                newWidth = newHeight * aspectRatio;
            } else {
                newHeight = newWidth / aspectRatio;
            }

            canvas.width = gameWidth;
            canvas.height = gameHeight;
            canvas.style.width = `${newWidth}px`;
            canvas.style.height = `${newHeight}px`;

            if(gameState.status === 'playing') render(); // Redesenha o estado atual
        }

        function init() {
            resetGameState();
            setupEventListeners();
            uiManager.showScreen('start-screen');
            audioManager.init();
            resizeCanvas(); // Ajusta o canvas no in√≠cio
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            if (gameState.status !== 'playing') return;

            if (!lastTime) lastTime = timestamp;
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            gameState.paddle.update(); // Passa o deltaTime implicitamente
            gameState.balls.forEach(ball => ball.update(deltaTime));
            gameState.powerUps.forEach(p => p.update(deltaTime));
            gameState.particles.forEach(p => p.update(deltaTime));
            handleCollisions();
            gameState.balls = gameState.balls.filter(b => b.active);
            gameState.powerUps = gameState.powerUps.filter(p => p.active);
            gameState.particles = gameState.particles.filter(p => p.active);
            gameState.bricks.forEach(brick => brick.update(deltaTime));

            if (gameState.balls.length === 0 && gameState.status === 'playing') {
                loseLife();
            }
            if (gameState.bricks.every(b => b.isDestroyed || b.type === 'I')) {
                levelComplete();
            }

            updateActiveEffects(deltaTime);
            uiManager.updatePowerUpIndicators();
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState.screenShake > 0) {
                ctx.save();
                const dx = Math.random() * gameState.screenShake;
                const dy = Math.random() * gameState.screenShake;
                ctx.translate(dx, dy);
                gameState.screenShake *= 0.9;
            }

            gameState.bricks.forEach(b => b.render(ctx));
            if(gameState.paddle) gameState.paddle.render(ctx);
            gameState.balls.forEach(b => b.render(ctx));
            gameState.powerUps.forEach(p => p.render(ctx));
            gameState.particles.forEach(p => p.render(ctx));
            if(gameState.paddle && gameState.paddle.shield) gameState.paddle.renderShield(ctx);

            if (gameState.screenShake > 0) {
                ctx.restore();
            }
        }
        
        function startGame(level) {
            if (gameState.status === 'playing') return;
            if (level) {
                gameState.score = 0;
                gameState.lives = 3;
            } else {
                 level = gameState.currentLevel;
            }
            gameState.status = 'playing';
            levelLoader.loadLevel(level);
            uiManager.updateAll();
            uiManager.showScreen(null);
            lastTime = 0;
            requestAnimationFrame(gameLoop);
        }

        function loseLife() {
            gameState.lives--;
            audioManager.playSound('loseLife');
            uiManager.updateLives();
            if (gameState.lives <= 0) {
                gameOver();
            } else {
                resetBallAndPaddle();
            }
        }

        function gameOver() {
            gameState.status = 'gameOver';
            audioManager.playSound('gameOver');
            if (gameState.timerId) clearInterval(gameState.timerId);
            const isNewHigh = highscoreManager.isHighScore(gameState.score);
            uiManager.showGameOverScreen(gameState.score, isNewHigh);
        }
        
        function levelComplete() {
            if (gameState.status !== 'playing') return;
            gameState.status = 'levelComplete';
            audioManager.playSound('levelComplete');
            if (gameState.timerId) clearInterval(gameState.timerId);
            if(gameState.timer !== null && gameState.timer > 0) {
                gameState.score += gameState.timer * 10;
            }
            if (gameState.currentLevel === gameState.playerProgress.unlockedLevel) {
                gameState.playerProgress.unlockedLevel++;
                localStorage.setItem('unlockedLevel', gameState.playerProgress.unlockedLevel);
            }
            if (gameState.currentLevel >= TOTAL_LEVELS) {
                gameComplete();
                return;
            }
            uiManager.showLevelCompleteScreen(gameState.score);
        }

        function gameComplete() {
            gameState.status = 'gameComplete';
            const isNewHigh = highscoreManager.isHighScore(gameState.score);
            uiManager.showGameCompleteScreen(gameState.score, isNewHigh);
        }

        function addScore(points) {
            const multiplier = gameState.activeEffects['scoreMultiplier'] ? 2 : 1;
            gameState.score += points * multiplier;
            uiManager.updateScore();
        }

        function handleCollisions() {
            gameState.balls.forEach(ball => {
                // ** F√çSICA DE IMPACTO ** Colis√£o com raquete
                if (ball.vy > 0 && 
                    ball.y + ball.radius > gameState.paddle.y &&
                    ball.y - ball.radius < gameState.paddle.y + gameState.paddle.height &&
                    ball.x + ball.radius > gameState.paddle.x && 
                    ball.x - ball.radius < gameState.paddle.x + gameState.paddle.width) {
                    
                    ball.y = gameState.paddle.y - ball.radius;
                    let collidePoint = (ball.x - (gameState.paddle.x + gameState.paddle.width / 2)) / (gameState.paddle.width / 2);
                    let angle = collidePoint * (Math.PI / 2.5); 
                    
                    let currentSpeed = Math.hypot(ball.vx, ball.vy);
                    
                    ball.vx = currentSpeed * Math.sin(angle);
                    ball.vy = -currentSpeed * Math.cos(angle);
                    
                    // Adiciona velocidade da raquete
                    ball.vx += gameState.paddle.velocityX * 0.5;
                    
                    // Limita a velocidade m√°xima
                    const maxBallSpeed = ball.baseSpeed * 1.5;
                    const newSpeed = Math.hypot(ball.vx, ball.vy);
                    if (newSpeed > maxBallSpeed) {
                        const ratio = maxBallSpeed / newSpeed;
                        ball.vx *= ratio;
                        ball.vy *= ratio;
                    }

                    audioManager.playSound('paddle');
                }

                for (const brick of gameState.bricks) {
                    if (!brick.isDestroyed && brick.isColliding(ball)) {
                        brick.hit(ball);
                        break;
                    }
                }
            });

            gameState.powerUps.forEach(powerUp => {
                if (powerUp.x < gameState.paddle.x + gameState.paddle.width &&
                    powerUp.x + powerUp.width > gameState.paddle.x &&
                    powerUp.y < gameState.paddle.y + gameState.paddle.height &&
                    powerUp.y + powerUp.height > gameState.paddle.y) {
                    powerUp.activate();
                    powerUp.active = false;
                }
            });
        }
        
        function resetBallAndPaddle() {
            Object.keys(gameState.activeEffects).forEach(key => removePowerUp(key));
            const levelData = levelLoader.getCurrentLevelData() || LEVELS_DATA.levels[0];
            levelLoader.applyLevelConfig(levelData);

            gameState.paddle.x = (gameWidth - gameState.paddle.width) / 2;
            
            const ball = createBall(
                gameState.paddle.x + gameState.paddle.width / 2, 
                gameState.paddle.y - 10
            );
            ball.stuck = true;
            gameState.balls = [ball];
        }
        
        function startTimer(seconds) {
            if (gameState.timerId) clearInterval(gameState.timerId);
            gameState.timer = seconds;
            uiManager.updateTimer();
            gameState.timerId = setInterval(() => {
                gameState.timer--;
                uiManager.updateTimer();
                if(gameState.timer <= 0) {
                    clearInterval(gameState.timerId);
                    if(gameState.status === 'playing') loseLife();
                }
            }, 1000);
        }
        
        function applyPowerUp(type) {
            audioManager.playSound('powerup');
            
            if(type.isBonus) {
                if(type.id === 'widePaddle' && gameState.activeEffects['shortPaddle']) removePowerUp('shortPaddle');
            }
            if(!type.isBonus) {
                if(type.id === 'shortPaddle' && gameState.activeEffects['widePaddle']) removePowerUp('widePaddle');
                if(type.id === 'fastBall' && gameState.activeEffects['slowBall']) removePowerUp('slowBall');
            }
            if (type.id === 'extraLife') {
                gameState.lives++;
                uiManager.updateLives();
                return;
            }
            if (type.id === 'multiBall') {
                for(let i=0; i<2; i++) {
                   const newBall = createBall(gameState.paddle.x + gameState.paddle.width/2, gameState.paddle.y - 10);
                   newBall.vx = (Math.random() - 0.5) * gameState.balls[0].baseSpeed;
                   newBall.vy = -Math.sqrt(Math.pow(gameState.balls[0].baseSpeed, 2) - Math.pow(newBall.vx, 2));
                   gameState.balls.push(newBall);
                }
                return;
            }
            if (type.id === 'shield') {
                gameState.paddle.shield = true;
            }
            if (type.duration) {
                if (gameState.activeEffects[type.id]) {
                    gameState.activeEffects[type.id].duration = type.duration;
                } else {
                     gameState.activeEffects[type.id] = { 
                        duration: type.duration,
                        icon: type.icon,
                        remove: type.onRemove,
                        id: type.id
                    };
                    if (type.onApply) type.onApply();
                }
            }
        }

        function removePowerUp(effectId) {
            const effect = gameState.activeEffects[effectId];
            if (effect) {
                if (effect.remove) effect.remove();
                delete gameState.activeEffects[effectId];
            }
             if (effectId === 'shield') {
                gameState.paddle.shield = false;
            }
        }

        function updateActiveEffects(deltaTime) {
            for (const key in gameState.activeEffects) {
                const effect = gameState.activeEffects[key];
                effect.duration -= deltaTime;
                if (effect.duration <= 0) {
                    removePowerUp(key);
                }
            }
        }
        
        // ... (UI, ENTITIES, ETC... SEM MUDAN√áAS DR√ÅSTICAS, APENAS PEQUENOS AJUSTES) ...
        const uiManager = {
            scoreEl: document.querySelector('#score span'),
            levelEl: document.querySelector('#level span'),
            livesEl: document.querySelector('#lives span'),
            timerEl: document.querySelector('#timer'),
            powerupIndicatorsEl: document.getElementById('powerup-indicators'),
            
            overlays: {
                'start-screen': document.getElementById('start-screen'),
                'level-select-screen': document.getElementById('level-select-screen'),
                'highscore-screen': document.getElementById('highscore-screen'),
                'game-over-screen': document.getElementById('game-over-screen'),
                'level-complete-screen': document.getElementById('level-complete-screen'),
                'game-complete-screen': document.getElementById('game-complete-screen'),
            },

            updateScore() { this.scoreEl.textContent = gameState.score; },
            updateLevel() { this.levelEl.textContent = gameState.currentLevel; },
            updateLives() { this.livesEl.textContent = '‚ù§Ô∏è'.repeat(gameState.lives); },
            updateTimer() {
                if (!this.timerEl) {
                    const timerDiv = document.createElement('div');
                    timerDiv.id = 'timer';
                    timerDiv.className = 'ui-element';
                    document.getElementById('ui-bar').appendChild(timerDiv);
                    this.timerEl = timerDiv;
                }
                this.timerEl.textContent = `TIME: ${gameState.timer}`;
            },
            
            removeTimer() {
                if (this.timerEl) {
                    this.timerEl.remove();
                    this.timerEl = null;
                }
            },
            
            updateAll() {
                this.updateScore();
                this.updateLevel();
                this.updateLives();
            },
            
            showScreen(screenId) {
                Object.values(this.overlays).forEach(o => o.classList.remove('visible'));
                if (screenId && this.overlays[screenId]) {
                    this.overlays[screenId].classList.add('visible');
                }
            },

            showGameOverScreen(score, isNewHigh) {
                document.getElementById('final-score').textContent = `Sua pontua√ß√£o final: ${score}`;
                const newHighscoreDiv = document.getElementById('new-highscore-entry');
                if (isNewHigh) {
                    newHighscoreDiv.style.display = 'block';
                    document.getElementById('nickname-input').value = '';
                    document.getElementById('nickname-input').focus();
                } else {
                    newHighscoreDiv.style.display = 'none';
                }
                this.showScreen('game-over-screen');
            },

            showLevelCompleteScreen(score) {
                document.getElementById('level-complete-score').textContent = `Pontua√ß√£o: ${score}`;
                this.showScreen('level-complete-screen');
            },
            
            showGameCompleteScreen(score, isNewHigh) {
                document.getElementById('final-score-win').textContent = `Sua pontua√ß√£o final: ${score}`;
                const newHighscoreDiv = document.getElementById('new-highscore-entry-win');
                if (isNewHigh) {
                    newHighscoreDiv.style.display = 'block';
                     document.getElementById('nickname-input-win').value = '';
                    document.getElementById('nickname-input-win').focus();
                } else {
                    newHighscoreDiv.style.display = 'none';
                }
                this.showScreen('game-complete-screen');
            },
            
            renderLevelSelect() {
                const grid = document.getElementById('level-select-grid');
                grid.innerHTML = '';
                const unlockedLevel = gameState.playerProgress.unlockedLevel;
                for (let i = 1; i <= TOTAL_LEVELS; i++) {
                    const box = document.createElement('div');
                    box.classList.add('level-box');
                    if (i <= unlockedLevel) {
                        box.classList.add('unlocked');
                        box.textContent = i;
                        box.dataset.level = i;
                        box.addEventListener('click', () => {
                            startGame(i);
                        });
                    } else {
                        box.classList.add('locked');
                    }
                    grid.appendChild(box);
                }
                this.showScreen('level-select-screen');
            },
            
            renderHighScores() {
                const tableBody = document.querySelector('#highscore-table tbody');
                const scores = highscoreManager.getScores();
                tableBody.innerHTML = '';
                scores.forEach((score, index) => {
                    const row = `<tr><td>${index + 1}</td><td>${score.name}</td><td>${score.score}</td></tr>`;
                    tableBody.innerHTML += row;
                });
                this.showScreen('highscore-screen');
            },

            updatePowerUpIndicators() {
                this.powerupIndicatorsEl.innerHTML = '';
                for (const key in gameState.activeEffects) {
                    const effect = gameState.activeEffects[key];
                    const indicator = document.createElement('div');
                    indicator.className = 'powerup-icon';
                    indicator.textContent = `${effect.icon} ${Math.ceil(effect.duration)}`;
                    
                    if (!POWER_UP_TYPES[effect.id].isBonus) {
                        indicator.style.borderColor = '#ff6b6b';
                    }

                    this.powerupIndicatorsEl.appendChild(indicator);
                }
            }
        };

        function createPaddle(x, y, width, height) {
            return {
                x, y, width, height,
                prevX: x,
                velocityX: 0,
                shield: false,
                laserActive: false,
                laserCooldown: 0,
                // ** F√çSICA DE IMPACTO **
                update() {
                    this.velocityX = this.x - this.prevX;
                    this.prevX = this.x;
                    
                    if (this.x < 0) this.x = 0;
                    if (this.x + this.width > gameWidth) this.x = gameWidth - this.width;
                },
                render(ctx) {
                    const r = this.height / 2;
                    ctx.fillStyle = this.laserActive ? '#feca57' : '#0984e3';
                    ctx.strokeStyle = '#636e72';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x + r, this.y);
                    ctx.lineTo(this.x + this.width - r, this.y);
                    ctx.arc(this.x + this.width - r, this.y + r, r, -Math.PI / 2, Math.PI / 2, false);
                    ctx.lineTo(this.x + r, this.y + this.height);
                    ctx.arc(this.x + r, this.y + r, r, Math.PI / 2, -Math.PI / 2, false);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.lineWidth = 1;
                },
                renderShield(ctx) {
                    ctx.fillStyle = 'rgba(2, 178, 237, 0.3)';
                    ctx.fillRect(0, gameHeight - 5, gameWidth, 5);
                }
            };
        }

        function createBall(x, y) {
            const levelConf = levelLoader.getCurrentLevelData().config;
            return {
                x, y, 
                radius: 7,
                baseSpeed: levelConf.ballSpeed,
                vx: 0,
                vy: -levelConf.ballSpeed,
                active: true,
                stuck: true,
                isGhost: false,
                isDrunk: false,
                drunkTimer: 0,
                
                update(deltaTime) {
                    if (this.stuck) {
                        this.x = gameState.paddle.x + gameState.paddle.width / 2;
                        this.y = gameState.paddle.y - this.radius;
                        return;
                    }
                    if(this.isDrunk) {
                        this.drunkTimer += deltaTime * 20;
                        this.x += Math.sin(this.drunkTimer) * 1.5;
                    }
                    this.x += this.vx;
                    this.y += this.vy;
                    if (this.x - this.radius < 0 || this.x + this.radius > gameWidth) { this.vx *= -1; audioManager.playSound('wall'); }
                    if (this.y - this.radius < 0) { this.vy *= -1; audioManager.playSound('wall'); }
                    if (this.y + this.radius > gameHeight) {
                         if(gameState.paddle.shield) {
                            this.y = gameHeight - this.radius; this.vy *= -1; audioManager.playSound('shield');
                        } else { this.active = false; }
                    }
                },
                render(ctx) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.isGhost ? 'rgba(255,255,255,0.5)' : '#ffffff';
                    ctx.fill();
                    ctx.closePath();
                }
            };
        }

        const BRICK_TYPES = {
            '1': { color: '#4a69bd', hp: 1, points: 10, powerUpChance: 0.1 },
            '2': { color: '#f0932b', hp: 2, points: 25, powerUpChance: 0.15 },
            'E': { color: '#eb4d4b', hp: 1, points: 50, special: 'explosive', powerUpChance: 0.3 },
            'I': { color: '#636e72', hp: Infinity, points: 0, special: 'indestructible' },
            'S': { color: '#00cec9', hp: 1, points: 20, special: 'powerup', powerUpChance: 1.0, fixedPowerUp: 'shield' },
            'W': { color: '#1dd1a1', hp: 1, points: 20, special: 'powerup', powerUpChance: 1.0, fixedPowerUp: 'widePaddle' },
            '+': { color: '#ff7979', hp: 1, points: 20, special: 'powerup', powerUpChance: 1.0, fixedPowerUp: 'extraLife' },
            'M': { color: '#54a0ff', hp: 1, points: 20, special: 'powerup', powerUpChance: 1.0, fixedPowerUp: 'multiBall' },
            'L': { color: '#feca57', hp: 1, points: 30, special: 'powerup', powerUpChance: 1.0, fixedPowerUp: 'laser' },
            'A': { color: '#c8d6e5', hp: 3, points: 75, special: 'armored', powerUpChance: 0.2 },
            'G': { color: 'rgba(162, 155, 254, 0.7)', hp: 2, points: 60, special: 'ghost', powerUpChance: 0.2 },
            'R': { color: '#55efc4', hp: 2, points: 70, special: 'regenerating', powerUpChance: 0.2 },
            'w': { color: '#d63031', hp: 1, points: 5, special: 'powerup', powerUpChance: 1.0, fixedPowerUp: 'shortPaddle' },
            'f': { color: '#e17055', hp: 1, points: 5, special: 'powerup', powerUpChance: 1.0, fixedPowerUp: 'fastBall' },
        };
        
        function createBrick(x, y, width, height, typeChar) {
            const type = BRICK_TYPES[typeChar] || BRICK_TYPES['1'];
            return {
                x, y, width, height, type: typeChar, hp: type.hp, maxHp: type.hp, points: type.points, color: type.color, special: type.special, isDestroyed: false, powerUpChance: type.powerUpChance, fixedPowerUp: type.fixedPowerUp, regenTimer: 0,
                render(ctx) { if (this.isDestroyed) return; let c = this.color; if(this.special === 'armored' && this.hp > 1) c = this.hp === 3 ? '#c8d6e5' : '#8395a7'; if(this.special === 'ghost') ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 200) * 0.2; ctx.fillStyle = c; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeStyle = '#1a1a2e'; ctx.lineWidth = 2; ctx.strokeRect(this.x, this.y, this.width, this.height); ctx.globalAlpha = 1.0; ctx.lineWidth = 1; },
                update(dt) { if(this.special === 'regenerating' && this.hp < this.maxHp && this.hp > 0) { this.regenTimer += dt; if(this.regenTimer > 5) { this.hp = this.maxHp; this.regenTimer = 0; audioManager.playSound('regenerate'); } } },
                isColliding(b) { if(this.isDestroyed) return false; if (this.special === 'ghost' && !b.isGhost) return b.x > this.x && b.x < this.x + this.width && b.y > this.y && b.y < this.y + this.height; return b.x + b.radius > this.x && b.x - b.radius < this.x + this.width && b.y + b.radius > this.y && b.y - b.radius < this.y + this.height; },
                hit(b) { if(this.special === 'regenerating') this.regenTimer = 0; this.hp--; createParticles(this.x + this.width / 2, this.y + this.height / 2, this.color, 10); if (this.hp > 0 && this.special !== 'armored') { this.color = BRICK_TYPES['1'].color; audioManager.playSound('brickHit'); } else if (this.hp <= 0) { this.destroy(); } else { audioManager.playSound('brickHit'); } if(this.special !== 'ghost' || b.isGhost) this.reflectBall(b); },
                destroy() { this.isDestroyed = true; addScore(this.points); audioManager.playSound('brickBreak'); createParticles(this.x + this.width / 2, this.y + this.height / 2, this.color, 30); if(this.special === 'explosive') this.explode(); if (Math.random() < this.powerUpChance) spawnPowerUp(this.x + this.width / 2, this.y + this.height / 2, this.fixedPowerUp); },
                reflectBall(b) { const oX = (b.radius+this.width/2)-Math.abs(b.x-(this.x+this.width/2)); const oY = (b.radius+this.height/2)-Math.abs(b.y-(this.y+this.height/2)); if(oX < oY) { b.vx *= -1; b.x += b.vx > 0 ? oX : -oX; } else { b.vy *= -1; b.y += b.vy > 0 ? oY : -oY; } },
                explode() { gameState.screenShake = 15; audioManager.playSound('explosion'); const r = this.width * 1.5; gameState.bricks.forEach(o => { if (o !== this && !o.isDestroyed) { const d = Math.hypot((this.x+this.width/2)-(o.x+o.width/2),(this.y+this.height/2)-(o.y+o.height/2)); if (d < r) o.destroy(); } }); }
            };
        }

        const POWER_UP_TYPES = {
            'widePaddle': { id: 'widePaddle', icon: 'W', color: '#1dd1a1', duration: 15, isBonus: true, onApply: () => gameState.paddle.width *= 1.5, onRemove: () => gameState.paddle.width /= 1.5 },
            'shield': { id: 'shield', icon: 'S', color: '#00cec9', duration: 10, isBonus: true },
            'extraLife': { id: 'extraLife', icon: '+', color: '#ff7979', isBonus: true },
            'multiBall': { id: 'multiBall', icon: 'M', color: '#54a0ff', isBonus: true },
            'laser': { id: 'laser', icon: 'L', color: '#feca57', duration: 15, isBonus: true, onApply: () => gameState.paddle.laserActive = true, onRemove: () => gameState.paddle.laserActive = false },
            'ghostBall': { id: 'ghostBall', icon: 'G', color: '#a29bfe', duration: 7, isBonus: true, onApply: () => gameState.balls.forEach(b => b.isGhost = true), onRemove: () => gameState.balls.forEach(b => b.isGhost = false) },
            'scoreMultiplier': { id: 'scoreMultiplier', icon: '2x', color: '#fdcb6e', duration: 20, isBonus: true },
            'shortPaddle': { id: 'shortPaddle', icon: 'w', color: '#d63031', duration: 15, isBonus: false, onApply: () => gameState.paddle.width *= 0.6, onRemove: () => gameState.paddle.width /= 0.6 },
            'fastBall': { id: 'fastBall', icon: 'F', color: '#e17055', duration: 20, isBonus: false, onApply: () => gameState.balls.forEach(b => { b.baseSpeed *= 1.4; }), onRemove: () => gameState.balls.forEach(b => { b.baseSpeed /= 1.4; }) },
            'drunkBall': { id: 'drunkBall', icon: '?', color: '#6c5ce7', duration: 15, isBonus: false, onApply: () => gameState.balls.forEach(b => b.isDrunk = true), onRemove: () => gameState.balls.forEach(b => b.isDrunk = false) }
        };

        function spawnPowerUp(x, y, fixedType = null) { let k; if(fixedType) k = fixedType; else { const ks = Object.keys(POWER_UP_TYPES); k = ks[Math.floor(Math.random() * ks.length)]; } gameState.powerUps.push(createPowerUp(x, y, POWER_UP_TYPES[k])); }
        function createPowerUp(x, y, type) { return { x: x - 15, y, width: 30, height: 15, type: type, speed: 2, active: true, update() { this.y += this.speed; if (this.y > gameHeight) this.active = false; }, render(ctx) { ctx.fillStyle = this.type.color; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.font = "bold 12px 'Press Start 2P'"; ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.type.icon, this.x + this.width / 2, this.y + this.height / 2 + 2); }, activate() { applyPowerUp(this.type); } }; }
        function createParticles(x, y, color, count) { for (let i = 0; i < count; i++) { gameState.particles.push({ x, y, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, size: Math.random()*3+1, life: 1, color, active: true, update() { this.x += this.vx; this.y += this.vy; this.life -= 0.04; if (this.life <= 0) this.active = false; }, render(ctx) { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1; } }); } }
        const levelLoader = { getCurrentLevelData() { return LEVELS_DATA.levels.find(l => l.level === gameState.currentLevel) || LEVELS_DATA.levels[0]; }, applyLevelConfig(d) { const c = d.config; gameState.paddle.width = c.paddleWidth; if(gameState.balls[0]) gameState.balls[0].baseSpeed = c.ballSpeed; if (c.timer) startTimer(c.timer); else { uiManager.removeTimer(); gameState.timer = null; } }, loadLevel(n) { gameState.currentLevel = n; const d = this.getCurrentLevelData(); if (!d) { gameComplete(); return; } gameState.bricks=[]; gameState.powerUps=[]; gameState.particles=[]; gameState.activeEffects={}; if (!gameState.paddle) gameState.paddle = createPaddle((gameWidth-100)/2, gameHeight - 30, 100, 15); resetBallAndPaddle(); this.createBricksFromLayout(d.layout); uiManager.updateAll(); }, createBricksFromLayout(l) { const rC = l.length; const cC = l[0].length; const bW = gameWidth / cC; const bH = 30; l.forEach((r, rI) => { for (let cI = 0; cI < cC; cI++) { const ch = r[cI]; if (ch !== '0' && ch !== ' ') gameState.bricks.push(createBrick(cI*bW, rI*bH+50, bW, bH, ch)); } }); } };
        const audioManager = { sounds: {}, isReady: false, async init() { if(this.isReady) return; await Tone.start(); this.sounds.brickHit = new Tone.Synth({oscillator:{type:'square'},envelope:{attack:0.01,decay:0.1,sustain:0,release:0.1}}).toDestination(); this.sounds.brickBreak=new Tone.MembraneSynth().toDestination(); this.sounds.paddle=new Tone.PluckSynth({attackNoise:0.5,dampening:4000,resonance:0.7}).toDestination(); this.sounds.wall=new Tone.PluckSynth({attackNoise:0.2,dampening:6000,resonance:0.5}).toDestination(); this.sounds.powerup=new Tone.Synth({oscillator:{type:'triangle'},envelope:{attack:0.01,decay:0.3,sustain:0.1,release:0.3}}).toDestination(); this.sounds.explosion=new Tone.NoiseSynth({noise:{type:'pink'},envelope:{attack:0.01,decay:0.5,sustain:0}}).toDestination(); this.sounds.loseLife=new Tone.Synth({oscillator:{type:'sawtooth'},envelope:{attack:0.01,decay:0.5,sustain:0,release:0.2}}).toDestination(); this.sounds.levelComplete=new Tone.Synth({oscillator:{type:'sine'},envelope:{attack:0.1,decay:0.5,sustain:0.2,release:1}}).toDestination(); this.sounds.gameOver=new Tone.Synth({oscillator:{type:'sawtooth'},envelope:{attack:0.2,decay:1,sustain:0,release:0.5}}).toDestination(); this.sounds.shield=new Tone.Synth({oscillator:{type:'sine'},envelope:{attack:0.01,decay:0.2,sustain:0,release:0.1}}).toDestination(); this.sounds.regenerate=new Tone.Synth({oscillator:{type:'sine'},envelope:{attack:0.2,decay:0.2,sustain:0,release:0.1}}).toDestination(); this.isReady = true; }, playSound(s) { if (!this.isReady) return; switch(s) { case 'brickHit': this.sounds.brickHit.triggerAttackRelease('C4','8n'); break; case 'brickBreak': this.sounds.brickBreak.triggerAttackRelease('C2','8n'); break; case 'paddle': this.sounds.paddle.triggerAttackRelease('C5','16n'); break; case 'wall': this.sounds.wall.triggerAttackRelease('G4','16n'); break; case 'powerup': this.sounds.powerup.triggerAttackRelease('C5',0.2); break; case 'explosion': this.sounds.explosion.triggerAttackRelease('16n'); break; case 'loseLife': this.sounds.loseLife.triggerAttackRelease('G2','4n'); break; case 'levelComplete': const n=Tone.now(); this.sounds.levelComplete.triggerAttackRelease('C4','8n',n); this.sounds.levelComplete.triggerAttackRelease('E4','8n',n+0.2); this.sounds.levelComplete.triggerAttackRelease('G4','8n',n+0.4); this.sounds.levelComplete.triggerAttackRelease('C5','4n',n+0.6); break; case 'gameOver': this.sounds.gameOver.triggerAttackRelease('C3','2n'); break; case 'shield': this.sounds.shield.triggerAttackRelease('A5','16n'); break; case 'regenerate': this.sounds.regenerate.triggerAttackRelease('G3','16n',Tone.now(),0.5); break; } } };
        const highscoreManager = { key: 'breakoutHighscores', getScores() { return JSON.parse(localStorage.getItem(this.key) || '[]'); }, saveScores(s) { localStorage.setItem(this.key, JSON.stringify(s)); }, addScore(n, s) { const sc = this.getScores(); sc.push({name: n, score: s}); sc.sort((a,b)=>b.score - a.score); this.saveScores(sc.slice(0, 10)); }, isHighScore(s) { if(s === 0) return false; const sc = this.getScores(); return sc.length < 10 || s > sc[sc.length - 1].score; } };

        // ==================================================================
        // EVENT LISTENERS
        // ==================================================================
        function setupEventListeners() {
            function movePaddle(clientX) {
                if (!gameState.paddle) return;
                const rect = canvas.getBoundingClientRect();
                const scale = gameWidth / rect.width;
                let mouseX = (clientX - rect.left) * scale;
                gameState.paddle.x = mouseX - gameState.paddle.width / 2;
            }

            document.addEventListener('mousemove', e => movePaddle(e.clientX));
            document.addEventListener('touchmove', e => {
                e.preventDefault();
                if (e.touches[0]) movePaddle(e.touches[0].clientX);
            }, { passive: false });
            
            function releaseBall() {
                if (gameState.status === 'playing' && gameState.balls.some(b => b.stuck)) {
                    gameState.balls.forEach(b => { if(b.stuck) b.stuck = false });
                }
            }

            canvas.addEventListener('click', releaseBall);
            canvas.addEventListener('touchend', releaseBall);

            document.getElementById('start-game-btn').addEventListener('click', () => startGame(1));
            document.getElementById('level-select-btn').addEventListener('click', () => uiManager.renderLevelSelect());
            document.getElementById('highscore-btn').addEventListener('click', () => uiManager.renderHighScores());
            document.querySelectorAll('.back-to-menu-btn').forEach(b => b.addEventListener('click', () => { resetGameState(); uiManager.showScreen('start-screen'); }));
            document.getElementById('play-again-btn').addEventListener('click', () => { resetGameState(); startGame(1); });
            document.getElementById('next-level-btn').addEventListener('click', () => { gameState.currentLevel++; startGame(gameState.currentLevel); });
            
            const submitScore = (inputId, isWin) => { const n = document.getElementById(inputId).value.trim() || 'AAA'; highscoreManager.addScore(n, gameState.score); if(isWin) document.getElementById('new-highscore-entry-win').style.display='none'; else document.getElementById('new-highscore-entry').style.display='none'; uiManager.renderHighScores(); }
            document.getElementById('submit-score-btn').addEventListener('click', () => submitScore('nickname-input', false));
            document.getElementById('submit-score-btn-win').addEventListener('click', () => submitScore('nickname-input-win', true));

            window.addEventListener('resize', resizeCanvas);
        }

        // Iniciar o jogo
        window.onload = init;

    </script>
</body>
</html>
