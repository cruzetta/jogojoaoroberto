<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Breakout Game - Níveis e Dificuldade</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden; /* Previne o scroll da página */
            touch-action: none; /* Desabilita gestos de toque padrão */
        }
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            text-align: center;
        }
        #game-wrapper {
            width: 100%;
            max-width: 600px; /* Limite máximo para telas grandes */
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            background: #000;
            display: block;
            width: 100%; /* Ocupa a largura do container */
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        #gameInfo {
            width: 100%;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
        }
        #message-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(26, 32, 44, 0.9);
            padding: 1.5rem 2rem;
            border-radius: 12px;
            border: 2px solid #4a5568;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            text-align: center;
            z-index: 10;
        }
        #message-text {
            white-space: pre; /* Permite quebras de linha com \n */
        }
        #play-again-button {
            margin-top: 1.5rem;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            color: #1a202c;
            background-color: #63b3ed;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            text-transform: uppercase;
        }
        #play-again-button:hover {
            background-color: #4299e1;
            transform: scale(1.05);
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <h1 class="text-3xl md:text-4xl mb-2 text-blue-300">Breakout Levels</h1>
    <div id="gameInfo" class="text-sm md:text-base">
        <span>PONTOS: <span id="score">0</span></span>
        <span>NÍVEL: <span id="level">1</span></span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="message-container" class="hidden">
        <h2 id="message-text" class="text-2xl md:text-3xl mb-2"></h2>
        <button id="play-again-button">Jogar Novamente</button>
    </div>
</div>

<script>
    // --- Elementos do DOM ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const levelElement = document.getElementById('level');
    const messageContainer = document.getElementById('message-container');
    const messageText = document.getElementById('message-text');
    const playAgainButton = document.getElementById('play-again-button');
    
    // --- Configuração de Som ---
    const synth = new Tone.PolySynth(Tone.Synth).toDestination();
    synth.volume.value = -8;
    const brickHitSound = () => synth.triggerAttackRelease("C5", "8n", Tone.now());
    const brickBreakSound = () => synth.triggerAttackRelease("E5", "8n", Tone.now());
    const wallHitSound = () => synth.triggerAttackRelease("G3", "8n", Tone.now());
    const paddleHitSound = () => synth.triggerAttackRelease("G4", "8n", Tone.now());
    const loseSound = () => synth.triggerAttackRelease("C3", "2n", Tone.now());
    const winSound = () => synth.triggerAttackRelease("G5", "2n", Tone.now());
    const levelUpSound = () => synth.triggerAttackRelease("C6", "4n", Tone.now());
    let audioStarted = false;

    // --- Estrutura dos Níveis ---
    // ' ' = Espaço vazio, '1' = Bloco normal, '2' = Bloco resistente
    const levelDesigns = [
        // Nível 1
        [
            " 11111 ",
            "1111111",
            "11 1 11",
            "1111111",
            " 11111 ",
        ],
        // Nível 2
        [
            "2222222",
            "2111112",
            " 21112 ",
            "  212  ",
            "   2   ",
        ],
        // Nível 3
        [
            "2 2 2 2",
            "1212121",
            "2121212",
            "1212121",
            " 2 2 2 ",
        ]
    ];
    const brickColors = {
        1: { main: "#22c55e", dark: "#166534" }, // Verde
        2: { main: "#f97316", dark: "#9a3412" }  // Laranja
    };

    // --- Variáveis Globais ---
    let animationFrameId;
    let score = 0;
    let level = 1;
    let breakableBricksCount = 0;
    const baseWidth = 480, baseHeight = 320;
    let scale = 1;
    let ballSpeed, ballRadius, x, y, dx, dy;
    let paddleHeight, paddleWidth, paddleX, lastPaddleX, paddleVelocity;
    let brickWidth, brickHeight, brickPadding, brickOffsetTop, brickOffsetLeft;
    let bricks = [];
    const maxAngleSteer = 5, paddleInfluenceFactor = 0.4;

    // --- Funções de Desenho ---
    function drawBall() { /* ...código inalterado... */ }
    function drawPaddle() { /* ...código inalterado... */ }
    function drawScore() {
        scoreElement.textContent = score;
        levelElement.textContent = level;
    }
    
    function drawBricks() {
        for (let c = 0; c < bricks.length; c++) {
            for (let r = 0; r < bricks[c].length; r++) {
                const b = bricks[c][r];
                if (b.status > 0) {
                    const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                    const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                    b.x = brickX;
                    b.y = brickY;
                    ctx.beginPath();
                    // Escolhe a cor baseada na vida (status) do bloco
                    ctx.fillStyle = b.status === 2 ? brickColors['2'].main : brickColors['1'].main;
                    ctx.roundRect(brickX, brickY, brickWidth, brickHeight, 3 * scale);
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }
    }
    
    // --- Lógica do Jogo ---
    function initializeBricksForLevel(levelNum) {
        bricks = [];
        breakableBricksCount = 0;
        const design = levelDesigns[levelNum - 1];
        if (!design) return;

        const designWidth = design[0].length;
        const designHeight = design.length;

        // Recalcular offset para centralizar o layout do nível
        brickOffsetLeft = (canvas.width - (designWidth * (brickWidth + brickPadding))) / 2 + (brickPadding/2);
        
        for (let c = 0; c < designWidth; c++) {
            bricks[c] = [];
            for (let r = 0; r < designHeight; r++) {
                const brickType = parseInt(design[r][c] || '0');
                if (brickType > 0) {
                    bricks[c][r] = { x: 0, y: 0, status: brickType };
                    breakableBricksCount++;
                } else {
                    bricks[c][r] = { x: 0, y: 0, status: 0 };
                }
            }
        }
    }

    function collisionDetection() {
        for (let c = 0; c < bricks.length; c++) {
            for (let r = 0; r < bricks[c].length; r++) {
                const b = bricks[c][r];
                if (b.status > 0) {
                    if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                        dy = -dy;
                        b.status--;
                        if (b.status === 0) {
                            brickBreakSound();
                            score += 10;
                            breakableBricksCount--;
                            if (breakableBricksCount <= 0) {
                                goToNextLevel();
                            }
                        } else {
                            brickHitSound();
                            score += 5;
                        }
                        drawScore();
                        return; // Evita múltiplas colisões no mesmo frame
                    }
                }
            }
        }
    }

    function draw() {
        // ...lógica de movimento e colisões com paredes e raquete (semelhante ao anterior)...
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBricks();
        drawBall();
        drawPaddle();
        collisionDetection();
        
        paddleVelocity = (paddleX - lastPaddleX) * paddleInfluenceFactor;

        if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
            dx = -dx;
            wallHitSound();
        }

        if (y + dy < ballRadius) {
            dy = -dy;
            wallHitSound();
        } else if (y + dy > canvas.height - ballRadius - paddleHeight) {
            if (x > paddleX && x < paddleX + paddleWidth) {
                dy = -dy;
                paddleHitSound();
                let impactPoint = (x - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
                let newDx = impactPoint * maxAngleSteer * scale;
                newDx += paddleVelocity;
                let currentSpeed = Math.sqrt(newDx * newDx + dy * dy);
                dx = (newDx / currentSpeed) * ballSpeed;
                dy = (dy / currentSpeed) * ballSpeed;
            } else {
                showEndGameMessage("FIM DE JOGO", true);
                return;
            }
        }

        x += dx;
        y += dy;
        lastPaddleX = paddleX;
        animationFrameId = requestAnimationFrame(draw);
    }
    
    // --- Controles e Eventos ---
    function handleMove(e) { /* ...código inalterado... */ }
    document.addEventListener('mousemove', handleMove, false);
    document.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); }, { passive: false });
    playAgainButton.addEventListener('click', fullReset);
    window.addEventListener('resize', fullReset);

    // --- Funções de Estado do Jogo ---
    function showEndGameMessage(message, isLoss = false) {
        cancelAnimationFrame(animationFrameId);
        messageText.textContent = message;
        messageContainer.classList.remove('hidden');
        if (isLoss) {
            loseSound();
        } else {
            winSound();
        }
    }

    function goToNextLevel() {
        cancelAnimationFrame(animationFrameId);
        level++;
        if (level > levelDesigns.length) {
            showEndGameMessage("VOCÊ VENCEU!\nPontuação Final: " + score);
        } else {
            levelUpSound();
            showEndGameMessage(`NÍVEL ${level}`, false);
            // Remove o botão de "jogar novamente" e continua automaticamente
            playAgainButton.classList.add('hidden');
            setTimeout(() => {
                messageContainer.classList.add('hidden');
                playAgainButton.classList.remove('hidden'); // Prepara para a próxima vez
                startLevel();
            }, 2000);
        }
    }
    
    function setGameParameters() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.width * (baseHeight / baseWidth);
        scale = canvas.width / baseWidth;

        ballRadius = 8 * scale;
        paddleHeight = 12 * scale;
        paddleWidth = 80 * scale;
        // Aumenta a velocidade da bola a cada nível
        ballSpeed = (3.5 + (level * 0.5)) * scale;
        
        const designWidth = levelDesigns[level - 1][0].length;
        brickPadding = 5 * scale;
        brickWidth = (canvas.width / designWidth) - brickPadding;
        brickHeight = 15 * scale;
        brickOffsetTop = 30 * scale;
    }

    function resetBallAndPaddle() {
        x = canvas.width / 2;
        y = canvas.height - (60 * scale);
        let angle = Math.random() * Math.PI / 2 + Math.PI / 4;
        dx = Math.cos(angle) * ballSpeed;
        dy = -Math.sin(angle) * ballSpeed;
        paddleX = (canvas.width - paddleWidth) / 2;
        lastPaddleX = paddleX;
        paddleVelocity = 0;
    }
    
    function startLevel() {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        setGameParameters();
        resetBallAndPaddle();
        initializeBricksForLevel(level);
        drawScore();
        draw();
    }

    function fullReset() {
        score = 0;
        level = 1;
        messageContainer.classList.add('hidden');
        startLevel();
    }
    
    // --- Início do Jogo ---
    fullReset();

    // Redefinição de funções para não serem redeclaradas
    drawBall = function() { ctx.beginPath(); ctx.arc(x, y, ballRadius, 0, Math.PI*2); ctx.fillStyle = "#63b3ed"; ctx.fill(); ctx.closePath(); }
    drawPaddle = function() { ctx.beginPath(); ctx.fillStyle = "#93c5fd"; ctx.roundRect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight, 10 * scale); ctx.fill(); ctx.closePath(); }
    handleMove = function(e) { if (!audioStarted) { Tone.start(); audioStarted = true; } const rect = canvas.getBoundingClientRect(); let clientX = e.clientX; if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; } const relativeX = clientX - rect.left; const newPaddleX = relativeX - paddleWidth / 2; if (newPaddleX > 0 && newPaddleX < canvas.width - paddleWidth) { paddleX = newPaddleX; } }
</script>
</body>
</html>
