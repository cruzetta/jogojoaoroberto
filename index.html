<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Breakout Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden; /* Previne o scroll da página */
            touch-action: none; /* Desabilita gestos de toque padrão */
        }
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            text-align: center;
        }
        #game-wrapper {
            width: 100%;
            max-width: 600px; /* Limite máximo para telas grandes */
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            background: #000;
            display: block;
            width: 100%; /* Ocupa a largura do container */
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        #gameInfo {
            width: 100%;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
        }
        #message-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(26, 32, 44, 0.9);
            padding: 2rem 3rem;
            border-radius: 12px;
            border: 2px solid #4a5568;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            text-align: center;
            z-index: 10;
        }
        #play-again-button {
            margin-top: 1.5rem;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            color: #1a202c;
            background-color: #63b3ed;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            text-transform: uppercase;
        }
        #play-again-button:hover {
            background-color: #4299e1;
            transform: scale(1.05);
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <h1 class="text-3xl md:text-4xl mb-2 text-blue-300">Breakout</h1>
    <div id="gameInfo">
        <span>PONTOS: <span id="score">0</span></span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="message-container" class="hidden">
        <h2 id="message-text" class="text-3xl mb-2"></h2>
        <button id="play-again-button">Jogar Novamente</button>
    </div>
</div>

<script>
    // --- Configuração do Canvas ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- Elementos do DOM ---
    const scoreElement = document.getElementById('score');
    const messageContainer = document.getElementById('message-container');
    const messageText = document.getElementById('message-text');
    const playAgainButton = document.getElementById('play-again-button');
    
    // --- Configuração de Som ---
    const synth = new Tone.PolySynth(Tone.Synth).toDestination();
    synth.volume.value = -6; 
    const brickHitSound = () => synth.triggerAttackRelease("C5", "8n");
    const wallHitSound = () => synth.triggerAttackRelease("G4", "8n");
    const loseSound = () => synth.triggerAttackRelease("C3", "2n");
    const winSound = () => synth.triggerAttackRelease("G5", "2n");
    let audioStarted = false;

    // --- Variáveis Globais do Jogo ---
    let animationFrameId;
    let score = 0;
    const baseWidth = 480; // Largura original para cálculo de escala
    const baseHeight = 320;
    let scale = 1;

    // --- Propriedades do Jogo (serão escaladas) ---
    let ballRadius, x, y, dx, dy;
    let paddleHeight, paddleWidth, paddleX;
    let brickRowCount, brickColumnCount, brickWidth, brickHeight, brickPadding, brickOffsetTop, brickOffsetLeft;
    
    const brickColors = ["#ef4444", "#f97316", "#eab308", "#84cc16", "#22c55e"];
    let bricks = [];

    // --- Funções de Desenho ---
    function drawBall() {
        ctx.beginPath();
        ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = "#63b3ed";
        ctx.fill();
        ctx.closePath();
    }

    function drawPaddle() {
        ctx.beginPath();
        ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
        ctx.fillStyle = "#93c5fd";
        ctx.fill();
        ctx.closePath();
    }

    function drawBricks() {
        for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
                if (bricks[c][r].status === 1) {
                    const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                    const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                    bricks[c][r].x = brickX;
                    bricks[c][r].y = brickY;
                    ctx.beginPath();
                    ctx.rect(brickX, brickY, brickWidth, brickHeight);
                    ctx.fillStyle = brickColors[r];
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }
    }

    function drawScore() {
        scoreElement.textContent = score;
    }
    
    // --- Lógica do Jogo ---
    function initializeBricks() {
        bricks = [];
        for (let c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 1 };
            }
        }
    }

    function collisionDetection() {
        for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
                const b = bricks[c][r];
                if (b.status === 1) {
                    if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                        dy = -dy;
                        b.status = 0;
                        brickHitSound();
                        score++;
                        drawScore();
                        if (score === brickRowCount * brickColumnCount) {
                            showEndGameMessage("VOCÊ VENCEU!");
                        }
                    }
                }
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBricks();
        drawBall();
        drawPaddle();
        collisionDetection();

        if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
            dx = -dx;
            wallHitSound();
        }
        if (y + dy < ballRadius) {
            dy = -dy;
            wallHitSound();
        } else if (y + dy > canvas.height - ballRadius) {
            if (x > paddleX && x < paddleX + paddleWidth) {
                dy = -dy;
                wallHitSound();
            } else {
                showEndGameMessage("FIM DE JOGO");
                return;
            }
        }

        x += dx;
        y += dy;

        animationFrameId = requestAnimationFrame(draw);
    }
    
    // --- Controles e Eventos ---
    function handleMove(e) {
        if (!audioStarted) {
            Tone.start();
            audioStarted = true;
        }
        const rect = canvas.getBoundingClientRect();
        let clientX = e.clientX;
        // Usa o primeiro toque se for um evento de toque
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
        }
        const relativeX = clientX - rect.left;
        if (relativeX > 0 && relativeX < canvas.width) {
            paddleX = relativeX - paddleWidth / 2;
        }
    }

    document.addEventListener('mousemove', handleMove, false);
    document.addEventListener('touchmove', (e) => {
        e.preventDefault(); // Previne o scroll ao tocar na tela
        handleMove(e);
    }, { passive: false });
    
    playAgainButton.addEventListener('click', fullReset);
    window.addEventListener('resize', fullReset);

    // --- Funções de Estado do Jogo ---
    function showEndGameMessage(message) {
        cancelAnimationFrame(animationFrameId);
        messageText.textContent = message;
        messageContainer.classList.remove('hidden');
        if (message.includes("VENCEU")) {
            winSound();
        } else {
            loseSound();
        }
    }
    
    function setGameParameters() {
        // Redimensiona o canvas
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.width * (baseHeight / baseWidth);
        
        scale = canvas.width / baseWidth;

        // Escala todos os parâmetros do jogo
        ballRadius = 8 * scale;
        paddleHeight = 10 * scale;
        paddleWidth = 75 * scale;
        brickRowCount = 5;
        brickColumnCount = 7;
        brickWidth = 55 * scale;
        brickHeight = 15 * scale;
        brickPadding = 5 * scale;
        brickOffsetTop = 30 * scale;
        brickOffsetLeft = (canvas.width - (brickColumnCount * (brickWidth + brickPadding))) / 2 + (brickPadding/2);
    }

    function resetGameVariables() {
        score = 0;
        x = canvas.width / 2;
        y = canvas.height - (30 * scale);
        dx = 3 * scale;
        dy = -3 * scale;
        paddleX = (canvas.width - paddleWidth) / 2;
    }

    function fullReset() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        messageContainer.classList.add('hidden');
        setGameParameters();
        resetGameVariables();
        initializeBricks();
        drawScore();
        draw();
    }
    
    // --- Início do Jogo ---
    fullReset();

</script>
</body>
</html>
